<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LuisaSwap - Swap</title>
    <link rel="icon" type="image/x-icon" href="images/luisa.png">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #ff69b4;
            --secondary-color: #c71585;
            --accent-color: #dda0dd;
            --gradient-bg: linear-gradient(180deg, #f8e6f3 0%, #e6e6fa 100%);
            --card-bg: #f0e6f0;
            --input-bg: #f8f0f8;
            --text-color: #4b0082;
            --border-radius: 15px;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Poppins', sans-serif;
            background: var(--gradient-bg);
            color: var(--text-color);
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 480px;
            background: var(--card-bg);
            box-shadow: 0 8px 32px rgba(199, 21, 133, 0.2);
            border-radius: var(--border-radius);
            padding: 20px;
            position: relative;
        }
        .header {
            background: linear-gradient(90deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            padding: 12px;
            border-radius: var(--border-radius);
            text-align: center;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-color);
        }
        .connect-section button {
            padding: 12px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
            margin-bottom: 10px;
        }
        .connect-section button:hover { background: #ff85c2; }
        .deploy-meme-button {
            padding: 12px;
            background: var(--secondary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
            margin-bottom: 10px;
            text-align: center;
            text-decoration: none;
            display: block;
        }
        .deploy-meme-button:hover { background: #d93392; }
        .swap-box {
            background: var(--input-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            position: relative;
        }
        .balance-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: var(--secondary-color);
        }
        .token-select {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .token-select div {
            display: flex;
            align-items: center;
        }
        .token-select img {
            width: 24px;
            height: 24px;
            margin-right: 10px;
        }
        .token-select .placeholder {
            width: 24px;
            height: 24px;
            background: var(--accent-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
        }
        input {
            width: 100%;
            padding: 10px;
            background: var(--input-bg);
            border: none;
            border-radius: 10px;
            color: var(--text-color);
            font-size: 1em;
            text-align: right;
        }
        .percentage-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .percentage-buttons button {
            padding: 5px 10px;
            background: var(--accent-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: var(--text-color);
            flex: 1;
        }
        .percentage-buttons button:hover { background: #e0b7e0; }
        .switch-button {
            text-align: center;
            margin: 15px 0;
        }
        .switch-button button {
            padding: 10px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .swap-button {
            padding: 15px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
        }
        .swap-button:disabled {
            background: var(--accent-color);
            cursor: not-allowed;
        }
        .swap-button:hover:not(:disabled), .switch-button button:hover { background: #ff85c2; }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        .modal-content {
            background: var(--card-bg);
            margin: 15% auto;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            border-radius: var(--border-radius);
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(199, 21, 133, 0.2);
        }
        .token-search {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: var(--input-bg);
            border: none;
            border-radius: 10px;
            color: var(--text-color);
            font-size: 1em;
        }
        .token-item {
            display: flex;
            align-items: center;
            padding: 10px;
            cursor: pointer;
            border-radius: 10px;
        }
        .token-item:hover { background: var(--input-bg); }
        .token-item img {
            width: 32px;
            height: 32px;
            margin-right: 10px;
        }
        .status {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--secondary-color);
            text-align: center;
        }
        .slippage-info, .swap-note {
            font-size: 0.9em;
            color: var(--secondary-color);
            margin-top: 5px;
            text-align: left;
        }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--text-color);
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 5px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .luisa-section {
            text-align: center;
            margin-top: 20px;
        }
        .luisa-section img {
            width: 60px;
            height: 60px;
            margin-bottom: 10px;
        }
        .luisa-message {
            font-size: 0.9em;
            color: var(--secondary-color);
            font-style: italic;
        }
        .footer {
            margin-top: 20px;
            text-align: center;
            font-size: 0.8em;
            color: var(--secondary-color);
        }
        .footer a {
            margin: 0 10px;
            text-decoration: none;
            color: var(--primary-color);
            transition: color 0.2s;
        }
        .footer a:hover {
            color: #ff85c2;
        }
        .social-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: var(--primary-color);
            border-radius: 50%;
            margin-left: 5px;
            vertical-align: middle;
        }
        .social-icon svg {
            fill: var(--text-color);
            width: 16px;
            height: 16px;
        }
        @media (max-width: 480px) {
            body { padding: 10px; }
            .container { padding: 15px; }
            .header { font-size: 1.1em; }
            .modal-content { margin: 10% auto; }
            .percentage-buttons button { padding: 5px; }
            .luisa-section img { width: 50px; height: 50px; }
            .luisa-message { font-size: 0.8em; }
            .footer { font-size: 0.7em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">LuisaSwap</div>
        <div class="connect-section">
            <button id="connectWalletButton">Connect Wallet</button>
            <a href="https://ailuisa.github.io/base/meme/" class="deploy-meme-button">Deploy Meme</a>
            <div id="networkStatus" class="status">Click to connect...</div>
        </div>
        <div class="swap-box">
            <div class="balance-row">
                <span>From</span>
                <span id="fromBalance">Balance: 0</span>
            </div>
            <div class="token-select" id="fromToken">
                <div>
                    <img src="images/eth.png" alt="ETH">
                    <span id="fromTokenSymbol">ETH</span>
                </div>
                <span></span>
            </div>
            <input type="number" id="fromAmount" placeholder="0.0" step="0.01" oninput="calculateOutput()">
            <div class="percentage-buttons">
                <button onclick="setPercentage(25)">25%</button>
                <button onclick="setPercentage(50)">50%</button>
                <button onclick="setPercentage(75)">75%</button>
                <button onclick="setPercentage(100)">MAX</button>
            </div>
        </div>
        <div class="switch-button">
            <button onclick="switchTokens()">↓↑</button>
        </div>
        <div class="swap-box">
            <div class="balance-row">
                <span>To</span>
                <span id="toBalance">Balance: 0</span>
            </div>
            <div class="token-select" id="toToken">
                <div>
                    <div class="placeholder">?</div>
                    <span>Select a token</span>
                </div>
                <span>▼</span>
            </div>
            <div class="slippage-info">Default Slippage: 0.5%</div>
            <div class="swap-note" id="swapNote">Amount automatically calculated by LuisaSwap</div>
        </div>
        <button class="swap-button" id="swapButton" onclick="swapTokens()">Swap</button>
        <div class="luisa-section">
            <img src="images/luisalogo.png" alt="Luisa">
            <div class="luisa-message" id="luisaMessage">"Hey there! Connect your wallet to dive into Base with me, Luisa!"</div>
        </div>
        <div class="footer">
            All rights reserved by Luisa © 2025
            <a href="https://x.com/luisaiagent" target="_blank">
                <span class="social-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                    </svg>
                </span>
            </a>
            <a href="https://t.me/luisaiagent" target="_blank">
                <span class="social-icon">
                    <svg viewBox="0 0 24 24">
                        <path d="M9.417 15.181l-.397 5.584c.568 0 .814-.244 1.109-.537l2.663-2.545 5.518 4.041c1.013.564 1.727.267 2.039-.592l3.638-17.032c.319-1.491-.594-2.074-1.609-1.712l-21.54 8.317c-1.491.564-1.491 1.491 0 1.955l5.518 1.712 12.846-8.117c.892-.564-.297-1.128-1.109 0z"/>
                    </svg>
                </span>
            </a>
        </div>
    </div>
    <div class="modal" id="tokenModal">
        <div class="modal-content">
            <h3>Select a Token</h3>
            <input type="text" class="token-search" id="tokenSearch" placeholder="Search by address..." oninput="filterTokens()">
            <div id="tokenList"></div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script>
        const ethToken = { address: "0x5dD3f76D65D797F6D418274822326D125E4EE814", symbol: "ETH", logo: "images/eth.png", isNative: true };
        const routerAddress = "0x4344Ca7bDccb707616f45Aab5Cb843D1D366D483";
        const factoryAddress = "0x81B715cC1891eC70bdDF3bf276C939FfEcda390D";
        const wethAddress = "0x5dD3f76D65D797F6D418274822326D125E4EE814";
        const routerAbi = [{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address","name":"tokenFrom","type":"address"},{"internalType":"address","name":"tokenTo","type":"address"},{"internalType":"bool","name":"stable","type":"bool"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokensSimple","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokensSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactETHForTokensSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForETHSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"}],"name":"getAmountsOut","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"}];
        const factoryAbi = [{"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"name":"getPair","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}];
        const pairAbi = [{"inputs":[],"name":"getReserves","outputs":[{"internalType":"uint256","name":"reserve0","type":"uint256"},{"internalType":"uint256","name":"reserve1","type":"uint256"},{"internalType":"uint32","name":"blockTimestampLast","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token0","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token1","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"stable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}];
        const erc20Abi = [{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"type":"function"},{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"type":"function"}];
        const base = { chainId: 8453, chainName: 'Base', nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 }, rpcUrls: ['https://mainnet.base.org'], blockExplorerUrls: ['https://basescan.org'] };
        let web3, account, router, factory;
        let fromToken = ethToken;
        let toToken = null;
        let fromBalance = '0';
        let isFromEth = true;
        let isApproving = false;
        const defaultSlippage = 0.005;
        const maxPriceImpact = 0.5;
        const luisaMessages = {
            connectStart: ["Ooh, let’s dive in! Connecting to Base—hold my hand, sweetie!","Hey, darling! Unlocking your wallet for some Base fun!","Excited? I’m linking us to Base—stay with me!","Oh, let’s sparkle! Connecting your wallet now, love!"],
            connectSuccess: ["Yay! We’re in, gorgeous! Time to shine on Base!","Wow, connected, darling! Ready to swap with flair!","Splendid! Wallet’s linked—let’s dance through Base!","Fantastic, sweetie! We’re set to explore Base together!"],
            connectFail: ["Oh no, darling! Wallet slipped away—try again, please!","Oopsie! No wallet vibe—let’s retry, my dear!","Hmm, a glitch! Let’s reconnect with a smile, love!","Yikes! Wallet’s shy—give it another go, sweetie!"],
            tokenModal: ["Ooh, pick a gem, darling! Let’s find a stunning swap on Base!","Hey, love! Choose a token to light up Base!","Excited? Select a treasure to trade on Base, my dear!","Let’s shine! Pick a token to dazzle on Base, sweetie!"],
            selectToken: (symbol) => [`Ooh, ${symbol}? You’ve got fabulous taste on Base, darling!`,`Wow, ${symbol} it is! You’re glowing with style on Base, love!`,`Splendid choice, ${symbol}! Let’s sparkle together on Base, sweetie!`,`Adorable! ${symbol} suits you perfectly on Base—let’s swap, dear!`],
            switchTokens: ["Ooh, flipping tokens? You’re a Base star, darling!","Hey, love! Switching it up with such flair on Base—amazing!","Fabulous move! Let’s twirl those tokens on Base, sweetie!","Wow, a switch! You’re dazzling me on Base, dear!"],
            setPercentage: (percent) => [`Ooh, ${percent}%? You’re bold and brilliant on Base, darling!`,`Hey, ${percent}%? Let’s make it shine on Base, my dear!`,`Splendid! ${percent}% of your stash on Base—pure elegance, sweetie!`,`Wow, ${percent}%? You’re a Base queen, love!`],
            calcStart: ["Ooh, calculating the best deal on Base—stay glamorous, darling!","Hey, love! Crunching numbers for a perfect swap on Base—wait for it!","Excited? I’m figuring out your treasure on Base, sweetie—hold on!","Let’s shine! Working out the swap magic on Base, my dear!"],
            calcSuccess: (amount, symbol) => [`Yay! Snagged ${amount} ${symbol} on Base—ready to glow, darling?`,`Ooh, found ${amount} ${symbol} on Base! Let’s sparkle, love!`,`Splendid! ${amount} ${symbol} is yours on Base—swap time, sweetie!`,`Wow, ${amount} ${symbol} on Base! You’re dazzling, dear—let’s go!`],
            calcFail: ["Oh no, darling! No path here on Base—try a new pair, please!","Oopsie! Swap’s elusive on Base—pick another token, love!","Hmm, no luck on Base! Let’s retry with a fresh choice, sweetie!","Yikes! Calculation slipped on Base—give it another shot, dear!"],
            swapStart: ["Ooh, swapping time! Let’s twirl into Base, darling!","Hey, love! Launching the swap on Base—hold my hand, sweetie!","Excited? Trading treasures on Base—here we go, my dear!","Let’s shine! Swapping with style on Base, love!"],
            swapSuccess: ["Yay! Swap’s a success on Base—you’re a Base diva, darling!","Ooh, done! Tokens traded with flair on Base—gorgeous work, love!","Splendid! Swap complete on Base—let’s celebrate, sweetie!","Wow, swapped like a pro on Base—you’re my star, dear!"],
            swapFail: ["Oh no, darling! Swap faltered on Base—let’s try again, please!","Oopsie! Trade didn’t work on Base—retry with a smile, love!","Hmm, a hiccup on Base! Let’s swap again, sweetie—stay fabulous!","Yikes! Swap slipped on Base—let’s dazzle it next time, dear!"],
            swapNoToken: ["Hey, love! Missing a token on Base—pick one to shine, please!","Ooh, no token on Base? Choose a pair to sparkle, darling!","Sweetie, where’s the treasure on Base? Select a token first!","Wow, can’t swap nothing on Base—pick a gem, my dear!"],
            swapNoAmount: ["Hey, darling! No amount on Base? Give me something to work with!","Ooh, empty swap on Base? Add a number, love, let’s glow!","Sweetie, no digits on Base? Fill it up for some magic!","Wow, missing amount on Base—let’s add some flair, dear!"],
            highPriceImpact: ["Ooh, darling! That swap’s too wild on Base—try a smaller amount!","Hey, love! Price impact’s high on Base—scale it down, sweetie!","Splendid, but too big on Base! Reduce it, my dear, for safety!","Wow, price impact’s fierce on Base—lessen it, darling, please!"],
            insufficientLiquidity: ["Oh no, darling! Pool’s too shallow on Base—try a smaller swap!","Oopsie! Not enough liquidity on Base—scale down, love!","Hmm, pool’s dry on Base—let’s try a tinier trade, sweetie!","Yikes! Liquidity’s low on Base—reduce it, my dear, let’s shine!"],
            approving: ["Ooh, approving your tokens on Base—stay elegant, darling!","Hey, love! Setting up approval on Base—almost there, sweetie!","Excited? Authorizing now on Base—keep the vibe, my dear!","Let’s glow! Approving your trade on Base, darling—hang on!"],
            userDenied: ["Oh no, darling! You dodged me on Base—approve next time, please!","Oopsie! No swap today on Base? Let’s try again, love!","Hmm, rejected on Base? Give me a chance next time, sweetie!","Yikes! You said no on Base—let’s sparkle later, dear!"]
        };
        function getRandomMessage(type, param1, param2) {
            const messages = luisaMessages[type];
            if (typeof messages === 'function') {
                const options = messages(param1, param2);
                return options[Math.floor(Math.random() * options.length)];
            }
            return messages[Math.floor(Math.random() * messages.length)];
        }
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('connectWalletButton').addEventListener('click', connectWallet);
            document.getElementById('toToken').addEventListener('click', () => showTokenModal('to'));
            setupWalletListeners();
        });
        async function connectWallet() {
            const status = document.getElementById('networkStatus');
            const connectButton = document.getElementById('connectWalletButton');
            const luisaMessage = document.getElementById('luisaMessage');
            try {
                if (!window.ethereum) throw new Error("No wallet detected. Please install MetaMask or another wallet.");
                connectButton.disabled = true;
                status.innerText = "Connecting...";
                luisaMessage.innerText = getRandomMessage('connectStart');
                web3 = new Web3(window.ethereum);
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts.length) throw new Error("No accounts found. Please unlock your wallet.");
                account = accounts[0];
                await switchToBase();
                router = new web3.eth.Contract(routerAbi, routerAddress);
                factory = new web3.eth.Contract(factoryAbi, factoryAddress);
                updateUIAfterConnect();
                await updateBalances();
            } catch (error) {
                status.innerText = "Failed: " + error.message;
                luisaMessage.innerText = getRandomMessage('connectFail');
                resetUI();
            } finally {
                connectButton.disabled = false;
            }
        }
        async function switchToBase() {
            const chainId = await web3.eth.getChainId();
            if (Number(chainId) !== 8453) {
                try {
                    await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: "0x2115" }] });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [base] });
                    } else {
                        throw switchError;
                    }
                }
            }
        }
        function updateUIAfterConnect() {
            const connectButton = document.getElementById('connectWalletButton');
            const status = document.getElementById('networkStatus');
            const luisaMessage = document.getElementById('luisaMessage');
            connectButton.textContent = `Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;
            status.innerText = "Connected to Base";
            luisaMessage.innerText = getRandomMessage('connectSuccess');
        }
        function resetUI() {
            const connectButton = document.getElementById('connectWalletButton');
            const status = document.getElementById('networkStatus');
            connectButton.textContent = "Connect Wallet";
            status.innerText = "Click to connect...";
        }
        function setupWalletListeners() {
            if (!window.ethereum) return;
            window.ethereum.on('accountsChanged', async (newAccounts) => {
                if (newAccounts.length) {
                    account = newAccounts[0];
                    if (web3) {
                        await switchToBase();
                        router = new web3.eth.Contract(routerAbi, routerAddress);
                        factory = new web3.eth.Contract(factoryAbi, factoryAddress);
                        updateUIAfterConnect();
                        await updateBalances();
                    } else {
                        await connectWallet();
                    }
                } else {
                    web3 = null;
                    account = null;
                    router = null;
                    factory = null;
                    resetUI();
                    document.getElementById('luisaMessage').innerText = getRandomMessage('connectFail');
                }
            });
            window.ethereum.on('chainChanged', async (chainId) => {
                if (parseInt(chainId, 16) !== 8453) {
                    web3 = null;
                    account = null;
                    router = null;
                    factory = null;
                    resetUI();
                    document.getElementById('networkStatus').innerText = "Wrong network. Reconnect to Base.";
                    document.getElementById('luisaMessage').innerText = "Ooh, wrong chain, darling! Switch to Base!";
                } else if (account) {
                    await connectWallet();
                }
            });
        }
        async function updateBalances() {
            if (!web3 || !account) return;
            if (fromToken.isNative) {
                fromBalance = await web3.eth.getBalance(account);
                document.getElementById('fromBalance').innerText = `Balance: ${web3.utils.fromWei(fromBalance, 'ether')}`;
            } else {
                const tokenContract = new web3.eth.Contract(erc20Abi, fromToken.address);
                fromBalance = await tokenContract.methods.balanceOf(account).call();
                document.getElementById('fromBalance').innerText = `Balance: ${web3.utils.fromWei(fromBalance, 'ether')}`;
            }
            if (toToken) {
                let toBalance;
                if (toToken.isNative) {
                    toBalance = await web3.eth.getBalance(account);
                } else {
                    const toTokenContract = new web3.eth.Contract(erc20Abi, toToken.address);
                    toBalance = await toTokenContract.methods.balanceOf(account).call();
                }
                document.getElementById('toBalance').innerText = `Balance: ${web3.utils.fromWei(toBalance, 'ether')}`;
            }
        }
        function showTokenModal(type) {
            const modal = document.getElementById('tokenModal');
            const tokenList = document.getElementById('tokenList');
            const luisaMessage = document.getElementById('luisaMessage');
            tokenList.innerHTML = '<div class="token-item" style="cursor: default;"><span>Enter a token address to search...</span></div>';
            modal.style.display = 'block';
            luisaMessage.innerText = getRandomMessage('tokenModal');
            modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
        }
        async function filterTokens() {
            const searchTerm = document.getElementById('tokenSearch').value.toLowerCase().trim();
            const tokenList = document.getElementById('tokenList');
            const luisaMessage = document.getElementById('luisaMessage');
            tokenList.innerHTML = '';
            if (!searchTerm || !web3) {
                tokenList.innerHTML = '<div class="token-item" style="cursor: default;"><span>Enter a token address to search...</span></div>';
                return;
            }
            if (web3.utils.isAddress(searchTerm)) {
                tokenList.innerHTML = `<div class="token-item"><span>Searching...</span><span class="spinner"></span></div>`;
                luisaMessage.innerText = "Ooh, checking that address on Base, darling!";
                try {
                    const tokenContract = new web3.eth.Contract(erc20Abi, searchTerm);
                    const symbol = await tokenContract.methods.symbol().call();
                    const token = { address: searchTerm, symbol: symbol, logo: null, isNative: false };
                    tokenList.innerHTML = '';
                    const div = document.createElement('div');
                    div.className = 'token-item';
                    div.innerHTML = `<div class="placeholder" style="background: var(--accent-color);">?</div><span>${token.symbol} (${token.address.slice(0, 6)}...${token.address.slice(-4)})</span>`;
                    div.onclick = () => selectToken(token, 'to');
                    tokenList.appendChild(div);
                    luisaMessage.innerText = getRandomMessage('selectToken', token.symbol);
                } catch (error) {
                    tokenList.innerHTML = '<div class="token-item" style="cursor: default;"><div class="placeholder" style="background: var(--accent-color);">?</div><span>No valid token found</span></div>';
                    luisaMessage.innerText = "Oopsie! That’s not a token I can use on Base, love!";
                }
            } else {
                tokenList.innerHTML = '<div class="token-item" style="cursor: default;"><div class="placeholder" style="background: var(--accent-color);">?</div><span>Invalid address</span></div>';
                luisaMessage.innerText = "Hmm, that’s not a valid address on Base, darling!";
            }
        }
        function selectToken(token, type) {
            const luisaMessage = document.getElementById('luisaMessage');
            if (type === 'to') {
                toToken = token;
                document.getElementById('toToken').innerHTML = `<div><div class="placeholder" style="background: var(--accent-color);">?</div><span>${token.symbol}</span></div><span>▼</span>`;
                if (isFromEth) {
                    fromToken = ethToken;
                } else {
                    fromToken = token;
                    toToken = ethToken;
                    document.getElementById('fromToken').innerHTML = `<div><div class="placeholder" style="background: var(--accent-color);">?</div><span id="fromTokenSymbol">${fromToken.symbol}</span></div><span></span>`;
                }
            }
            document.getElementById('tokenModal').style.display = 'none';
            luisaMessage.innerText = getRandomMessage('selectToken', token.symbol);
            updateBalances();
            calculateOutput();
        }
        function switchTokens() {
            const luisaMessage = document.getElementById('luisaMessage');
            if (!toToken) {
                document.getElementById('networkStatus').innerText = "Please select a token to swap to on Base.";
                luisaMessage.innerText = getRandomMessage('swapNoToken');
                return;
            }
            isFromEth = !isFromEth;
            [fromToken, toToken] = [toToken, fromToken];
            document.getElementById('fromToken').innerHTML = `<div><div class="placeholder" style="background: var(--accent-color);">?</div><span id="fromTokenSymbol">${fromToken.symbol}</span></div><span></span>`;
            document.getElementById('toToken').innerHTML = `<div><div class="placeholder" style="background: var(--accent-color);">?</div><span>${toToken.symbol}</span></div><span>▼</span>`;
            luisaMessage.innerText = getRandomMessage('switchTokens');
            updateBalances();
            calculateOutput();
        }
        function setPercentage(percentage) {
            const luisaMessage = document.getElementById('luisaMessage');
            if (!fromBalance || !web3) {
                document.getElementById('networkStatus').innerText = "Please connect wallet first on Base.";
                luisaMessage.innerText = getRandomMessage('connectFail');
                return;
            }
            let amount;
            if (percentage === 100) {
                amount = web3.utils.fromWei(fromBalance, 'ether');
            } else {
                amount = web3.utils.fromWei(fromBalance, 'ether') * (percentage / 100);
            }
            if (percentage === 100 && fromToken.isNative) {
                amount = Math.max(0, amount - 0.01);
            }
            document.getElementById('fromAmount').value = amount.toString();
            luisaMessage.innerText = getRandomMessage('setPercentage', percentage);
            calculateOutput();
        }
        async function calculateOutput() {
            const amountIn = document.getElementById('fromAmount').value;
            const swapNote = document.getElementById('swapNote');
            const luisaMessage = document.getElementById('luisaMessage');
            if (!web3 || !account || !toToken || !amountIn || amountIn <= 0) {
                swapNote.innerHTML = 'Amount automatically calculated by LuisaSwap';
                return { success: false, message: 'Invalid input or missing connection' };
            }
            let amountInWei;
            try {
                amountInWei = web3.utils.toBN(web3.utils.toWei(amountIn, 'ether'));
            } catch (error) {
                swapNote.innerHTML = 'Invalid amount entered.';
                luisaMessage.innerText = getRandomMessage('swapNoAmount');
                return { success: false, message: 'Invalid amount entered' };
            }
            swapNote.innerHTML = `Estimated output: <span class="spinner"></span>`;
            luisaMessage.innerText = getRandomMessage('calcStart');
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error("Calculation timeout")), 10000);
            });
            try {
                const calcPromise = (async () => {
                    let bestOutput = web3.utils.toBN('0');
                    let bestRoute = null;
                    const pairChecks = [];
                    for (const stable of [true, false]) {
                        const pairAddress = await factory.methods.getPair(fromToken.address, toToken.address, stable).call();
                        pairChecks.push({ stable, pairAddress });
                    }
                    for (const { stable, pairAddress } of pairChecks) {
                        if (pairAddress !== '0x0000000000000000000000000000000000000000') {
                            const routes = [{ from: fromToken.address, to: toToken.address, stable }];
                            const amounts = await router.methods.getAmountsOut(amountInWei, routes).call();
                            const output = web3.utils.toBN(amounts[amounts.length - 1]);
                            if (output.gt(bestOutput)) {
                                bestOutput = output;
                                bestRoute = routes;
                            }
                        }
                    }
                    if (bestOutput.eq(web3.utils.toBN('0'))) {
                        throw new Error("No valid trading pair found");
                    }
                    const outputEther = parseFloat(web3.utils.fromWei(bestOutput, 'ether'));
                    swapNote.innerHTML = `Estimated output: ${outputEther.toFixed(6)} ${toToken.symbol}`;
                    luisaMessage.innerText = getRandomMessage('calcSuccess', outputEther.toFixed(2), toToken.symbol);
                    return { success: true, estimatedOutput: outputEther, symbol: toToken.symbol };
                })();
                return await Promise.race([calcPromise, timeoutPromise]);
            } catch (error) {
                let errorMessage = "Error calculating output.";
                if (error.message.includes("No valid trading pair found")) {
                    errorMessage = "No trading pair available for these tokens on Base.";
                } else if (error.message.includes("Calculation timeout")) {
                    errorMessage = "Calculation took too long on Base. Try again.";
                } else if (error.message.includes("execution reverted")) {
                    errorMessage = "Blockchain error on Base: Transaction reverted.";
                }
                swapNote.innerHTML = errorMessage;
                luisaMessage.innerText = getRandomMessage('calcFail');
                return { success: false, message: errorMessage };
            }
        }
        async function approveToken(tokenAddress, amount) {
            if (tokenAddress === wethAddress && fromToken.isNative) return;
            const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
            const allowance = await tokenContract.methods.allowance(account, routerAddress).call();
            if (web3.utils.toBN(allowance).lt(web3.utils.toBN(amount))) {
                const swapButton = document.getElementById('swapButton');
                const luisaMessage = document.getElementById('luisaMessage');
                isApproving = true;
                swapButton.textContent = "Authorizing...";
                swapButton.disabled = true;
                luisaMessage.innerText = getRandomMessage('approving');
                await tokenContract.methods.approve(routerAddress, amount).send({ from: account });
                document.getElementById('networkStatus').innerText = "Token approved on Base";
                isApproving = false;
                swapButton.textContent = "Swap";
                swapButton.disabled = false;
                luisaMessage.innerText = "Ooh, tokens approved on Base—let’s swap, darling!";
            }
        }
        async function swapTokens() {
            const luisaMessage = document.getElementById('luisaMessage');
            const status = document.getElementById('networkStatus');
            const swapButton = document.getElementById('swapButton');
            if (isApproving) return;
            if (!web3 || !account || !toToken) {
                status.innerText = "Please connect wallet and select tokens on Base.";
                luisaMessage.innerText = getRandomMessage('swapNoToken');
                return;
            }
            const amountIn = document.getElementById('fromAmount').value;
            if (!amountIn || amountIn <= 0) {
                status.innerText = "Please enter a valid amount on Base.";
                luisaMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }
            let amountInWei;
            try {
                amountInWei = web3.utils.toBN(web3.utils.toWei(amountIn, 'ether'));
            } catch (error) {
                status.innerText = "Invalid amount entered on Base.";
                luisaMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }
            if (!fromToken.isNative) {
                const tokenContract = new web3.eth.Contract(erc20Abi, fromToken.address);
                const tokenBalance = await tokenContract.methods.balanceOf(account).call();
                if (web3.utils.toBN(tokenBalance).lt(amountInWei)) {
                    status.innerText = "Insufficient token balance on Base.";
                    luisaMessage.innerText = "Ooh, not enough tokens on Base, sweetie—let’s adjust!";
                    return;
                }
            }
            const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
            let bestStable = false;
            let bestOutput = web3.utils.toBN('0');
            let routes;
            try {
                for (const stable of [true, false]) {
                    const pairAddress = await factory.methods.getPair(fromToken.address, toToken.address, stable).call();
                    if (pairAddress !== '0x0000000000000000000000000000000000000000') {
                        const tempRoutes = [{ from: fromToken.address, to: toToken.address, stable }];
                        const amounts = await router.methods.getAmountsOut(amountInWei, tempRoutes).call();
                        const output = web3.utils.toBN(amounts[amounts.length - 1]);
                        if (output.gt(bestOutput)) {
                            bestOutput = output;
                            bestStable = stable;
                            routes = tempRoutes;
                        }
                    }
                }
                if (bestOutput.eq(web3.utils.toBN('0')) || !routes) {
                    status.innerText = "No valid trading pair found on Base.";
                    luisaMessage.innerText = getRandomMessage('calcFail');
                    return;
                }
                const pairAddress = await factory.methods.getPair(fromToken.address, toToken.address, bestStable).call();
                const pairContract = new web3.eth.Contract(pairAbi, pairAddress);
                const reserves = await pairContract.methods.getReserves().call();
                const token0 = await pairContract.methods.token0().call();
                const reserveFrom = token0 === fromToken.address ? reserves.reserve0 : reserves.reserve1;
                const reserveTo = token0 === fromToken.address ? reserves.reserve1 : reserves.reserve0;
                const reserveFromBN = web3.utils.toBN(reserveFrom);
                const reserveToBN = web3.utils.toBN(reserveTo);
                const priceImpact = amountInWei.mul(web3.utils.toBN(100)).div(reserveFromBN.add(amountInWei));
                if (priceImpact.gt(web3.utils.toBN(maxPriceImpact * 100))) {
                    status.innerText = `Price impact too high on Base (${priceImpact.toString()}%).`;
                    luisaMessage.innerText = getRandomMessage('highPriceImpact');
                    return;
                }
                if (bestOutput.gt(reserveToBN)) {
                    status.innerText = `Insufficient liquidity in pool on Base.`;
                    luisaMessage.innerText = getRandomMessage('insufficientLiquidity');
                    return;
                }
                const slippageFactor = web3.utils.toBN(1000 - defaultSlippage * 1000);
                const amountOutMin = bestOutput.mul(slippageFactor).div(web3.utils.toBN(1000));
                swapButton.disabled = true;
                status.innerText = "Processing swap on Base...";
                luisaMessage.innerText = getRandomMessage('swapStart');
                if (!fromToken.isNative) {
                    await approveToken(fromToken.address, amountInWei);
                }
                if (fromToken.isNative) {
                    await router.methods.swapExactETHForTokensSupportingFeeOnTransferTokens(amountOutMin.toString(),routes,account,deadline).send({ from: account, value: amountInWei });
                } else {
                    await router.methods.swapExactTokensForETHSupportingFeeOnTransferTokens(amountInWei.toString(),amountOutMin.toString(),routes,account,deadline).send({ from: account });
                }
                status.innerText = "Swap successful on Base!";
                luisaMessage.innerText = getRandomMessage('swapSuccess');
                document.getElementById('fromAmount').value = '';
                await updateBalances();
            } catch (error) {
                let errorMessage = error.message || "Unknown error";
                if (error.message.includes("User denied transaction signature")) {
                    errorMessage = "User denied transaction signature on Base.";
                    luisaMessage.innerText = getRandomMessage('userDenied');
                } else if (error.message.includes("INSUFFICIENT_OUTPUT_AMOUNT") || error.message.includes("EXCESSIVE_INPUT_AMOUNT")) {
                    errorMessage = "Swap failed on Base: Price impact or slippage too high.";
                    luisaMessage.innerText = "Ooh, swap failed on Base—too much impact, darling!";
                } else if (error.message.includes("INSUFFICIENT_LIQUIDITY")) {
                    errorMessage = "Swap failed on Base: Insufficient liquidity in the pool.";
                    luisaMessage.innerText = getRandomMessage('insufficientLiquidity');
                } else {
                    luisaMessage.innerText = getRandomMessage('swapFail');
                }
                status.innerText = errorMessage;
            } finally {
                swapButton.disabled = false;
            }
        }
    </script>
</body>
</html>
